#!/usr/bin/env zsh
#
# Fancy prompt.
# The file is autoloaded as a function in the current shell context.

# Cheat Sheet:
#
# %B   - Start boldface mode
# %b   - Stop boldface mode
#
# %K   - Start using a different background color
# %k   - Stop using a different background color
#
# %F   - Start using a different foreground color
# %f   - Stop using a different foreground color
#
# %?   - Exit status
# %#   - A '#' if the shell is running with privileges, a '%' if not
# %~   - Current working directory

# Echoes a username/host string when connected over SSH
# (empty otherwise).
ssh_info() {
  local -a ssh_prompt

  if [ -n "${SSH_CONNECTION}" ]
  then
    ssh_prompt+=( '%F{blue}[' )  # [
    ssh_prompt+=( '%F{red}SSH' ) # SSH
    ssh_prompt+=( '%F{blue}] ' ) # ]
  fi

  # Join the words of arrays together.
  echo "${(j::)ssh_prompt}"
}

# Echoes information about Git repository status when inside a Git
# repository.
git_info() {
  # Exit if not inside a Git repository.
  ! git rev-parse --is-inside-work-tree > /dev/null 2>&1 && return

  # Git branch/tag, or name-rev if on detached head.
  local location
  location="$(git symbolic-ref -q HEAD || git name-rev --name-only --no-undefined --always HEAD)"
  location="${location#(refs/heads/|tags/)}"

  [ "${#location}" -ge 24 ] && location="${location:0:21}..."

  location="${location:-no branch}"

  local status_dirty
  if [ "$(git --no-optional-locks status --untracked-files='no' --porcelain)" ]
  then
    status_dirty='%F{green}*'
  else
    unset status_dirty
  fi

  local ahead="%{$fg[red]%}⇡num%{$reset_color%}"
  local behind="%{$fg[cyan]%}⇣num%{$reset_color%}"
  local merging="%{$fg[magenta]%}⚡︎%{$reset_color%}"
  local untracked="%{$fg[red]%}●%{$reset_color%}"
  local modified="%{$fg[yellow]%}●%{$reset_color%}"
  local staged="%{$fg[green]%}●%{$reset_color%}"

  local -a divergences
  local -a flags

  local num_ahead="$(git log --oneline @{u}.. 2> /dev/null | wc -l | tr -d ' ')"
  if [ "$num_ahead" -gt 0 ]
  then
    divergences+=( "${ahead//num/$num_ahead}" )
  fi

  local num_behind="$(git log --oneline ..@{u} 2> /dev/null | wc -l | tr -d ' ')"
  if [ "$num_behind" -gt 0 ]
  then
    divergences+=( "${behind//num/$num_behind}" )
  fi

  local git_dir="$(git rev-parse --git-dir 2> /dev/null)"
  if [ -n $git_dir ] && test -r $git_dir/MERGE_HEAD; then
    flags+=( "$merging" )
  fi

  if [[ -n $(git ls-files --other --exclude-standard 2> /dev/null) ]]
  then
    flags+=( "$untracked" )
  fi

  if ! git diff --quiet 2> /dev/null
  then
    flags+=( "$modified" )
  fi

  if ! git diff --cached --quiet 2> /dev/null
  then
    flags+=( "$staged" )
  fi

  local -a git_prompt

  git_prompt+=( "\033[38;5;15m± " )       # ±
  git_prompt+=( "%F{yellow}${location}" ) # branch

  if [ ${#divergences[@]} -ne 0 ]
  then
    git_prompt+=( " ${(j::)divergences}" ) # divergences
  fi

  if [ ${#flags[@]} -ne 0 ]
  then
    git_prompt+=( " ${(j::)flags}" )      # status
  fi

  # Join the words of arrays together.
  echo "${(j::)git_prompt}"
}

# function ptfancy {

theme=()
theme+=( '%B%F{cyan}%(!.%m.%n@%m)%k' )           # host
theme+=( ' %(?..%F{blue}[%F{253}%?%F{blue}] )' ) # exit status
theme+=( '$(ssh_info)' )                         # ssh onfo
theme+=( '%B%F{blue}%~ ' )                       # cwd
theme+=( '$(git_info)' )                         # git info
theme+=( '%F{blue} %# ' )                        # use '#' for root
theme+=( '%b%f%k' )                              # reset colors

# Join the words of arrays together.
# By convention, themes use PS1, PS2, RPS1, etc., rather than the
# longer PROMPT and RPROMPT.
PS1=${(j::)theme}

# Cleanup unnecessary variables.
unset theme

# }

# Local Variables:
# mode: sh
# End:
