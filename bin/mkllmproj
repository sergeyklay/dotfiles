#!/usr/bin/env bash
#
# mkllmproj - LLM project scaffolding tool.
#
# Copyright (C) 2024 Serghei Iakovlev <gnu@serghei.pl>
#
# This file is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# This file is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this file.  If not, see <https://www.gnu.org/licenses/>.

# shellcheck shell=bash

# trace ERR through pipes
set -o pipefail

# trace ERR through 'time command' and other functions
set -o errtrace

# set -u : exit the script if you try to use an uninitialised variable
set -o nounset

# set -e : exit the script if any statement returns a non-true return value
set -o errexit

IFS=$'\n\t'

# Constants
readonly SCRIPT_NAME="${0##*/}"
readonly VERSION="1.1.0"

version() {
  cat <<EOF
${SCRIPT_NAME} ${VERSION}
Copyright (C) 2025 Serghei Iakovlev.
This is free software; see the source for copying conditions. There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOF
}

usage() {
  cat << EOF
${SCRIPT_NAME} - LLM project scaffolding tool [version ${VERSION}]

Usage:	${SCRIPT_NAME} [options] [[--] name]

Description:
  ${SCRIPT_NAME} is a tool for creating standardized scaffolding for LLM
  (Large Language Model) projects, setting up common directories and
  configuration files needed for LLM development.

Examples:
  # Create a project named "myproject" with a description
  \$ ${SCRIPT_NAME} myproject -d "This is a description of my LLM project."

  # Create a project named "myproject" without a description (will be prompted)
  \$ ${SCRIPT_NAME} myproject

  # Create a project and install dependencies automatically
  \$ ${SCRIPT_NAME} myproject --install

  # Create a project in a specific directory
  \$ ${SCRIPT_NAME} myproject --path /path/to/directory

  # Ask for project name and description, and install dependencies automatically
  \$ ${SCRIPT_NAME} --install

  # Ask for project name and description, and skip dependency installation
  \$ ${SCRIPT_NAME} --no-install

Positional parameters:
  name                      Project name (optional)
                            If not provided, will prompt interactively
Command options:
  -h, --help                Show this help message
  -V, --version             Show program's version number
  -d, --description         Project description (optional)
                            If not provided, will prompt interactively
      --install             Install dependencies without prompting
      --no-install          Skip dependency installation
      --path                Directory where project should be created
                            If not provided, uses current directory
  --                        Terminates option parsing

For bug reporting instructions, please see:
<https://github.com/sergeyklay/dotfiles/>.
EOF
}

project_name=""
project_description=""
install_deps=""
project_path=""
original_dir=$(pwd)

# Ensure we return to the original directory
cleanup() {
  cd "$original_dir"
}
trap cleanup EXIT

# Process command line options
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    -V|--version)
      version
      exit 0
      ;;
    -d|--description)
      shift
      project_description="$1"
      shift
      ;;
    --install)
      install_deps="yes"
      shift
      ;;
    --no-install)
      install_deps="no"
      shift
      ;;
    --path)
      shift
      project_path="$1"
      shift
      ;;
    --)
      # Everything after -- is a positional parameter
      shift
      if [[ $# -gt 0 ]]; then
        project_name="$1"
        shift
      fi
      break
      ;;
    -*)
      {
        echo "${SCRIPT_NAME}: invalid option: $1"
        echo "Try '${SCRIPT_NAME} --help' for more information."
      } 1>&2
      exit 1
      ;;
    *)
      if [[ -z "$project_name" ]]; then
        project_name="$1"
      else
        {
          echo "${SCRIPT_NAME}: unexpected argument: $1"
          echo "Try '${SCRIPT_NAME} --help' for more information."
        } 1>&2
        exit 1
      fi
      shift
      ;;
  esac
done

# Change to project directory if specified
if [[ -n "$project_path" ]]; then
  if [[ ! -d "$project_path" ]]; then
    mkdir -p "$project_path" || {
      echo "${SCRIPT_NAME}: failed to create directory $project_path" >&2
      exit 1
    }
  fi
  cd "$project_path" || {
    echo "${SCRIPT_NAME}: failed to change to directory $project_path" >&2
    exit 1
  }
fi

# Validate project name if provided as argument
if [[ -n "$project_name" ]]; then
  if [[ -z "${project_name// }" ]]; then
    echo "${SCRIPT_NAME}: project name cannot be empty" >&2
    exit 1
  fi
else
  # Prompt for project name if not provided
  while [[ -z "${project_name// }" ]]; do
    read -rp "Enter project name: " project_name
    if [[ -z "${project_name// }" ]]; then
      echo "${SCRIPT_NAME}: project name cannot be empty" >&2
    fi
  done
fi

# Prompt for project description if not provided
if [[ -z "$project_description" ]]; then
  read -rp "Enter project description (press Enter to skip): " project_description
fi

# If description is empty, use a default value
if [[ -z "$project_description" ]]; then
  project_description="LLM project"
fi

# Normalize project name
project_name_normalized=$(echo "$project_name" | tr '[:upper:]' '[:lower:]' | tr ' ' '-')

# Create project files
create_env() {
  cat > .env << 'EOL'
LANGSMITH_TRACING=true
LANGSMITH_ENDPOINT=https://api.smith.langchain.com
LANGSMITH_API_KEY=

MODEL=gpt-4o-mini

OPENAI_API_KEY=
EOL
}

create_gitignore() {
  cat > .gitignore << 'EOL'
.venv
.env
__pycache__
EOL
}

create_main() {
  cat > main.py << 'EOL'
import os
from pathlib import Path
from typing import Any, TypedDict

from dotenv import load_dotenv
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI


load_dotenv(dotenv_path=Path(__file__).resolve().parent / ".env")


class TranslationInput(TypedDict):
    adjective: str
    noun: str


def create_llm(
    model: str,
    temperature: float = 0.5,
    max_tokens: int = 256,
    **kwargs: Any,
) -> ChatOpenAI:
    """Create a ChatOpenAI instance with specified configuration.

    Args:
        model: The model identifier
        temperature: Controls randomness in the output (0.0 to 2.0)
        max_tokens: Maximum number of tokens to generate
        **kwargs: Additional parameters to pass to ChatOpenAI

    Returns:
        Configured ChatOpenAI instance
    """
    return ChatOpenAI(
        model=model,
        temperature=temperature,
        max_tokens=max_tokens,
        **kwargs,
    )


def verify_environment() -> None:
    """Verify that all required environment variables are set."""
    # Feel free to add more environment variables
    # or remove the ones that are not required
    required_env_vars = [
        "LANGSMITH_TRACING",
        "LANGSMITH_ENDPOINT",
        "LANGSMITH_API_KEY",
        "MODEL",
        "OPENAI_API_KEY",
    ]

    missing_vars = [var for var in required_env_vars if var not in os.environ]
    if missing_vars:
        raise ValueError(
            "Missing required environment variables: "
            f"{', '.join(missing_vars)}. Please set them in your .env file."
        )


if __name__ == "__main__":
    try:
        verify_environment()
    except ValueError as e:
        print(e)
        exit(1)

    model = create_llm(
        model=os.environ["MODEL"],
        temperature=0.3,
        max_tokens=500,
        request_timeout=30,    # Custom timeout in seconds
        top_p=0.9,             # Nucleus sampling parameter
    )

    system_template = (
        "You are a nice AI bot that helps people with their questions. "
        "You should provide clear, direct answers."
    )

    template = ChatPromptTemplate([
        ("system", system_template),
        ("human", "How many stars are there in the sky?"),
        ("ai", "There are 88 constellations in the sky."),
        ("human", "Who is man's {adjective} {noun}?"),
    ])

    prompt = template.invoke(
        TranslationInput(
            adjective="best",
            noun="friend",
        )
    )

    response = model.invoke(prompt)
    print(response.content)
EOL
}

create_pyproject() {
  cat > pyproject.toml << EOL
[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.poetry]
name = "${project_name_normalized}"
version = "1.0.0"
description = "${project_description}"
authors = ["Serghei Iakovlev <gnu@serghei.pl>"]
license = "GPL-3.0-or-later"
readme = "README.md"
keywords = []
classifiers = []
packages = []
include = []

[tool.poetry.dependencies]
python = ">=3.10, <4"
python-dotenv = "^1.0.0"
langsmith = "^0.2.11"
langchain-core = "^0.3.31"
langchain-openai = "^0.3.1"
langchain_community = "^0.3.15"

[tool.poetry.group.dev.dependencies]
debugpy = "^1.8.9"
EOL
}

create_readme() {
  cat > README.md << EOL
# ${project_name}

## Description

${project_description}

## Installation

\`\`\`bash
poetry install --with=dev --no-root
\`\`\`

## Usage

\`\`\`bash
poetry run python main.py
# or
python main.py
\`\`\`

## License

This project is licensed under the GPL-3.0 License - see the LICENSE file for details.
EOL
}

install_dependencies() {
  # Skip prompting if --install or --no-install was specified
  if [[ -z "$install_deps" ]]; then
    read -rp "Do you want to install dependencies? [y/N] " install_deps
  fi

  if [[ "${install_deps,,}" =~ ^y(es)?$ ]]; then
    # Check if poetry is installed
    if ! command -v poetry &> /dev/null; then
      echo "${SCRIPT_NAME}: poetry is not installed. Please install poetry first."
      exit 1
    fi

    poetry install --with=dev --no-root
  fi
}

main() {
  # Create project files
  create_env
  create_gitignore
  create_main
  create_pyproject
  create_readme
  install_dependencies

  echo "Project ${project_name} has been created successfully!"
}

main "$@"

# Local Variables:
# mode: sh
# End:
